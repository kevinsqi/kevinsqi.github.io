{"componentChunkName":"component---src-templates-blog-post-js","path":"/three-talks/","result":{"data":{"site":{"siteMetadata":{"title":"Kevin Qi","author":"Kevin Qi"}},"markdownRemark":{"id":"630a10a2-97b6-582e-bb2d-871bd244015a","excerpt":"Here are a couple talks with “ah-ha” moments that made me think about programming in a new way. Cheng Lou — “On the Spectrum of Abstraction” This talk is…","html":"<p>Here are a couple talks with “ah-ha” moments that made me think about programming in a new way.</p>\n<h2>Cheng Lou — “On the Spectrum of Abstraction”</h2>\n<div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 56.25%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem\" > <iframe src=\"https://www.youtube.com/embed/mVVNJKv9esE\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" style=\" position: absolute; top: 0; left: 0; width: 100%; height: 100%; \"></iframe> </div>\n<p>This talk is particularly useful for library and framework authors, as it delves into how to think about the level of abstraction a library should provide. That doesn’t sound widely applicable at first, but as complex client side apps emerge, it’s becoming more and more common for frontend developers to write generic component libraries and to have to think about what functionality and what abstractions they provide.</p>\n<p>The idea that really resonated with me is the visualization of a tree of “use cases”, where leaf nodes are concrete use cases and parent nodes are the abstract tools that enable those use cases. If you create a tool that’s very specific and tailored, you only cover a few leaf nodes. If you create a tool that’s very abstract, you can potentially cover many leaf nodes, but there will then be additional layers of abstraction between the tool and the eventual leaf node use-case. A library should strike the balance between that immediate usefulness, and the ability to cover many “leaf nodes”. I found this to be an interesting and useful mental image to have.</p>\n<p>Another core idea was that enforcing restrictions on expressivity can be a beneficial tool. The corollary to that idea is that increasing expressiveness can be a negative trade-off. The prime example is how React approaches rendering vs. the approach of using templates. Templates are “data” — they can be fully expressed as serializable data structures, whereas React rendering can utilize functions, which can’t be expressed as data. Cheng said that this was actually a concession, not an inherently desired trait, which was something that was unexpected and thought provoking. By restricting expressiveness by using templates, frameworks like Ember can apply performance optimizations that React cannot. But the expressiveness gained with functions was worth the tradeoff.</p>\n<h2>Sandi Metz — ”The Wrong Abstraction”</h2>\n<p>On the topic of abstractions — <a href=\"https://www.sandimetz.com/blog/2016/1/20/the-wrong-abstraction\">The Wrong Abstraction</a> is based a talk by Sandi Metz. The idea is straightforward: it’s better to have code duplication than to have code reuse at the “wrong level of abstraction”, sharing code across disparate areas when the code really shouldn’t be shared at all.</p>\n<p>The idea that I found enlightening was the solution to the problem:</p>\n<blockquote>\n<p>If you find yourself in this situation, resist being driven by sunk costs. When dealing with the wrong abstraction, the fastest way forward is back.</p>\n</blockquote>\n<p>She suggests re-introducing duplication by inlining the abstracted code back into every caller. This approach is interesting because it’s rather obvious in principle, but something that I wouldn’t have thought of when approaching a particular chunk of over-shared code in practice.</p>\n<h2>Gary Bernhardt — “Boundaries”</h2>\n<div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 56.25%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem\" > <iframe src=\"https://www.youtube.com/embed/yTkzNHF6rMs\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\" style=\" position: absolute; top: 0; left: 0; width: 100%; height: 100%; \"></iframe> </div>\n<p>This talk covers a wide range of concepts: “functional core vs. imperative shell”, immutability, and parallelism. The concept I found most immediately applicable were Gary’s thoughts about integration tests vs. unit tests and mocking/stubbing.</p>\n<p>Going into the talk, I was strongly on board with integration testing as the best primary means of testing. However, Gary’s illustration of the exponential “path count” that’s inherent to integration testing and the increased cost in test suite runtime are solid arguments against an extremely integration-heavy approach, and are problems that I’ve run into in my own experience as well.</p>\n<p>Instead, Gary suggests a balanced approach to unit and integration testing. This is the slide that really nailed down the concept:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e1b99f1e3060c42b8cef07d38fd38b13/c391c/boundaries-slide.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACcUlEQVR42k2SS08TYRiF+0/ciAsWujGuNGHhxhgwcUGU1JhocGGMiYkYIUokoEQwiNGCigIWkEuhVHqndNpOO+20nZneptALRf0lj18HYlicnGTe5My5fDZP0EcguMaWe4HlpU8szk8x43hHVArTbJQxqzqmqVMV3Dg0OWxVaTQr1MXtNBrNMrV6GVtCDhCZG2J1uJ+o8xVBxwCBjfeEwwH0WJjdwDZhv4DgVGKXnJqgXM5Zws0T8ab4URv1tmBwcYnsyDOM6REK06Psz75ha3gQKRWjXiuQiodRMzHkiJdExE8yuYemKej5JEUtRamoouVTFIw0tVoJW+DbAks9V5m7fY3Hl8/z8WYX0z03kNIJqrkUlYJKo2UKTmMkQ5iGQjkvoyfDmMWMFfegVrRgRXZvuXh0q4eHvd3Yu65gv3SRJ/fuoihxTD1txWqKWEd/62hRL+lfK2R2VillJA5/H9Cw+quIfivHkfdiUaKJGJIcJ6VmiAp273iQpRAFWdx2vUgRH6VSltaf2nFfR/v/+zs9kOXw8+RLXPPTOD+MMjv2nG2xtGN8iKB3nf2KhnQiGAt5UKJ+NOFaiYdQFYlcNiEgUzFUDF2hWMxim3k7hGdZiIwNYu++jts5w/cpsbbfReOgSD4do2xqFLJx5O0VZJ8LVfKha8dDVKvGscN6STgUo0w+vc/G1wke3Onj7JkOHBNj/PwyjtflpKLKYumS1Z8phsj61lA2F8j618kFXdSqeVqix+bJ02nHt/V1duJ4PUC/vZcL5zr44RhndvIFm6vzVIQzo71uIYMh1tVycXQ9ZT0ZLZ+wvhli6fa90Gbh+B92AnUyAlWdcwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"boundaries slide\"\n        title=\"boundaries slide\"\n        src=\"/static/e1b99f1e3060c42b8cef07d38fd38b13/fcda8/boundaries-slide.png\"\n        srcset=\"/static/e1b99f1e3060c42b8cef07d38fd38b13/12f09/boundaries-slide.png 148w,\n/static/e1b99f1e3060c42b8cef07d38fd38b13/e4a3f/boundaries-slide.png 295w,\n/static/e1b99f1e3060c42b8cef07d38fd38b13/fcda8/boundaries-slide.png 590w,\n/static/e1b99f1e3060c42b8cef07d38fd38b13/c391c/boundaries-slide.png 673w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Gary’s argument here is that you put all your “decisions” in a functional core — the stuff that also tends to lead to an exponential explosion in testing paths. And you unit test that, because unit testing is fast and well-suited for testing multiple paths.</p>\n<p>With that done, you can test the integration of dependencies using integration tests and avoid the exponential branching paths (since that’s covered by unit tests).</p>","frontmatter":{"title":"Three talks that changed the way I think about programming","date":"January 6, 2019","description":"Here are a couple talks with “ah-ha” moments that made me think about programming in a new way."}}},"pageContext":{"slug":"/three-talks/","previous":null,"next":null}},"staticQueryHashes":["139983731","63159454"]}